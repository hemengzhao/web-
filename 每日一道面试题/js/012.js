let a = { n: 1 };
let b = a;
a.x = a = { n: 2 };
console.log(a.x); // undefined
console.log(b.x); // {n: 2}

// 分析
/***
 * 堆 中存放引用变量   栈中存放引用变量
 * 1. let a = {n: 1}  在内存中开辟一块内存区域{n:1} 暂定为堆A, a的值为地址指针指向堆A
 * 2. let b = a       把a的值赋值给b （即为堆（{n:1}）的地址指针）
 *                    a和b的值相同，是同一个地址指针
 *
 *      变量a  ----->  {n: 1} (堆A)
 *                       ^
 *                       |
 *      变量b  -----------
 *
 * 3. a.x = a = {n: 2}
 *    根据js引擎语法解析，会先去从左到右寻找有没有未声明的变量， 执行到a.x时，会在堆A创建x属性，赋值为undefined
 *    因为目前变量a和变量b指向的时同一个地址， 所以a.x也可以表示为b.x
 *
 *    语法解析完成后，开始进行运算(ps：赋值运算),首先依循“从右往左”的赋值运算顺序
 *    先执行 a={n:2}  这是会在堆中新建一个内存区域{n:2}，暂定为堆B， 将变量a的指针指向新的堆B
 *
 *    a.x(堆A) 赋值为为{n:2}的指针
 *
 *    变量a  ----->  {n: 2} (堆B)
 *
 *    变量b  ----->  {n: 1, x: {n: 2}} (堆A)
 *
 *    所以最终打印
 *      a.x --> 堆B.x  -->  undefined
 *      b.x --> 堆A.x  -->  {n: 2}
 */
